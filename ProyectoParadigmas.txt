#lang racket


;Definicion de(pixbit-d)
;Constructor pixbit-d
;Dominio: W(int) X Z(int) X bit(constante 0 1) X depth (int)
;Recorrido: pixbit-d
;Recursion: No se usa
;El bit en si es un numero por lo cual se considera solamente como 0 y 1

(define pixbit-d
  (lambda(X Y Bit Depth)
    (if(and(integer? X)
           (integer? Y)
           (or(= Bit 0)(= Bit 1))
           (integer? Depth))
       (cons X (cons Y(cons Bit(cons Depth null))))
       null)
    )
  )

;Ejemplo uso
;(pixbit-d 30 40 1 10)


;Selector(pixbit-d)
;Seleccionar la coordenada X del elemento pixbit-d
;Dominio: pixbit-d X elemento
;Recorrido: pixbit-d

(define Obtener-X
  (lambda(lista)
    (car lista)))

;Selector(pixbit-d)
;Seleccionar la coordenada Y del elemento pixbit-d

(define Obtener-Y
  (lambda(lista)
    (car(cdr lista))))

;Selector pixbit-d
;Seleccionar el bit del elemento pixbit-d

(define Obtener-Bit
  (lambda(lista)
    (car(cdr(cdr lista)))))

;Selector pixbit-d
;Seleccionar el depth del elemento pixbit-d

(define Obtener-Depth
  (lambda(lista)
    (car(cdr(cdr(cdr lista))))))



;Pertenencia pixbit-d
;Se genera la pertenencia para el constructor pixbit-d
;Dominio: pixbit-d
;Recorrido: Booleano
;Recursion: No se usa

(define pixbit-d?
  (lambda(Posiblepix)
    (cond
      [(=(length Posiblepix)4)#t]
      [(integer? (Obtener-X Posiblepix))#t]
      [(integer? (Obtener-Y Posiblepix))#t]
      [(or(=(Obtener-Bit Posiblepix)0)(=(Obtener-Bit Posiblepix)1))#t]
      [(integer? (Obtener-Depth))#t]
      [else #f])))


;TDA pixrgb-d (pixmap)
;Constructor para generar un pixbit
;Dominio: W(int) X Z(int) X R(C) X G(C) X B(C) X D(int)
;Recorrido: Pixmap
;Recursion: no se usa

(define pixrgb-d
  (lambda(X Y R G B D)
    (if(and(integer? X)
           (integer? Y)
           (<= R 255)(>= R 0)
           (<= G 255)(>= G 0)
           (<= B 255)(>= B 0)
           (integer? D))
       (cons X(cons Y(cons R(cons G(cons B(cons D null))))))
       null)
    )
  )

;Ejemplo uso
;(pixrgb-d 0 0 0 0 0 0)

;Selectores pixmap-d 
;No es necesario realizar los selectores para las coordenadas, ya que fueron creados
;Selector R, elemento color (Puede tomar valor entre 0 hasta 255)
;Selecciona el tercer elemento de la lista pixrgb-d

(define Obtener-R
  (lambda(lista)
    (car(cdr(cdr lista)))))

;Selector G, elemento color (Nuevamente puede tomar valores entre 0 y 255)
;Selecciona el cuarto elemento de la lista pixbit-d
(define Obtener-G
  (lambda(lista)
    (car(cdr(cdr(cdr lista))))))

;Selector B, elemento color (0-255)
;Selecciona el quinto elemento de la lista pixbit-d
(define Obtener-B
  (lambda(lista)
    (car(cdr(cdr(cdr(cdr lista)))))))

;Selector D, un valor entero cualquiera
;Selecciona el ultimo elemento de la lista pixbit-d
(define Obtener-D
  (lambda(lista)
    (car(cdr(cdr(cdr(cdr(cdr lista))))))))


;Pertenencia pixrgb-d
;Verifica la partenencia para dicho constructor
;Dominio: pixrgb-d
;Recorrido: booleano
;Recursi칩n: No se usa
(define (pixrgb-d? Posiblepix)
  (if (list? Posiblepix)
      (if (= (length Posiblepix) 6)
          (if (and (integer? (Obtener-X Posiblepix))
                   (integer? (Obtener-Y Posiblepix))
                   (((>=(Obtener-R Posiblepix)0)(<= Obtener-R Posiblepix)255))
                   (((>=(Obtener-G Posiblepix)0)(<= Obtener-R Posiblepix)255))
                   (((>=(Obtener-B Posiblepix)0)(<= Obtener-B Posiblepix)255))
                   ((integer? (Obtener-D Posiblepix))))
              #t
              #f
              )
          #f
          )
      #f
      )
  )

;Constructor(pixhex-d)
;Dominio: W(int) X Z(int) X hex(string) X d(int)
;Recorrido: pixhex-d
;Recursi칩n: No se usa
(define pixhex-d
  (lambda(X Y Hex D)
    (if(and(integer? X)
           (integer? Y)
           (string? Hex)
           (integer? D))
       (cons X(cons Y(cons Hex(cons D null))))
       null)))

;Ejemplo uso
;(pixhex-d 10 20 "Rojo" 0)


;Selectores pixhex-d
;Selecciona los elementos de la lista pixhex-d
;En este caso se tienen que tomar todos los elementos de esa lista
;Como se tienen el resto de elementos, solo se deben tomar los elementos hex y D
(define Obtener-Hex
  (lambda(lista)
    (car(cdr(cdr lista)))))

;Selector pixhex-d
;En este caso se hace seleccion del elemento D de la lista hex
;Debido a que las listas de elementos entre los tres tipos de pix son diferentes

(define Obtener-D-Hex
  (lambda(lista)
    (car(cdr(cdr(cdr lista))))))


;Pertenencia pixhex-d
;Aqui se construye la pertenencia de los elementos de tipo pixhex-d
;Dominio: pixhex-d
;Recorrido: Booleano
;Recursion: No se usa

(define (pixhex-d? Posiblepix)
  (if (list? Posiblepix)
      (if (= (length Posiblepix) 4)
          (if (and (integer? (Obtener-X Posiblepix))
                   (integer? (Obtener-Y Posiblepix))
                   (string? (Obtener-Hex Posiblepix))
                   (integer? (Obtener-D-Hex Posiblepix)))
              #t
              #f
              )
          #f
          )
      #f
      )
  )

;Constructor imagen
;Funcion constructora de la imagen
;Se deben tener los otros constructores para generar la imagen
;Dominio: Alto X Ancho X pixbit-d X pixrgb-d X pixhex-d
;Recorrido: Imagen
;Una vez obtenidos los contructores de los otros apartados, se debe construir el constructor central imagen

(define imagen
  (lambda(Alto Ancho . ConstructoresPrev)
    (cons Alto(cons Ancho(cons ConstructoresPrev null)))))

;La idea de esta funcion es utilizar los constructores generados
;Como funciones de n variable
;Ejemplo uso
;(imagen 2 2(pixbit-d 0 0 1 100)(pixbit-d 0 0 1 20)(pixbit-d 0 0 1 70)(pixbit-d 0 0 0 0))
;(imagen 2 2 (pixhex-d 0 0 "rojo" 100)(pixhex-d 0 0 "negro" 20)(pixhex-d 0 0 "blanco" 70)(pixhex-d 0 0 "azul" 0))
;(imagen 2 2 (pixrgb-d 0 0 0 0 0 0) (pixrgb-d 1 1 1 1 1 1) (pixrgb-d 0 0 0 255 255 10) (pixrgb-d 0 1 1 1 0 0))

;Selectores imagen
;Se tienen los siguiente selectores para los elementos de la imagen
;Se selecciona el alto de la imagen
(define Obtener-Alto
  (lambda(imagen)
    (car imagen)))

;Selector ancho imagen
;Se selecciona el ancho de la imagen
(define Obtener-Ancho
  (lambda(imagen)
    (car(cdr imagen))))

;Selector para los constructores previamente hechos
;Selecciona el ultimo elemento, es decir, las listas con los otros constructores
(define Obtener-Listas-Pixel
  (lambda(imagen)
    (car(cdr(cdr imagen)))))

;Pertenencia imagen
;Se dise침an las pertenencias en cuanto al constructor imagen a dise침ar, se usa lo previamente
;Dominio: Imagen
;Recorrido: Booleano
;Recursion: No se usa
;Se construye la pertenencia para un bitmap?

(define bitmap?
  (lambda(imagen)
    (pixbit-d? (Obtener-Listas-Pixel imagen))))

;Ejemplo uso:
;(bitmap? (imagen 2 2 (pixbit-d 0 0 1 10)(pixbit-d 0 1 0 20)(pixbit-d 1 0 0 30)(pixbit-d 1 1 1 4))) devuelve #t

;Pertenencia pixmap
;Se construye a base de los pixrgb-d?
;Dominio: imagen
;Recorrido: booleano
;Recursion: No se usa

(define pixmap?
  (lambda(imagen)
    (pixrgb-d? (Obtener-Listas-Pixel imagen))))

;Ejemplo uso:
;(pixmap? (imagen 2 2 (pixbit-d 0 0 1 10)(pixbit-d 0 1 0 20)(pixbit-d 1 0 0 30)(pixbit-d 1 1 1 4))) devuelve #f


;Pertenencia hexmap
;Se construye a partir de los pixhex-d?
;Dominio: imagen
;Recorrido: booleano
;Recursion: No se usa

(define hexmap?
  (lambda(imagen)
    (pixhex-d? (Obtener-Listas-Pixel imagen))))

;Ejemplo uso
;(hexmap? (imagen 2 2 (pixbit-d 0 0 1 100)(pixbit-d 0 0 1 20)(pixbit-d 0 0 1 70)(pixbit-d 0 0 0 0))) devuelve #f


;Funcion para verificar si se puede comprimir una imagen
;Dominio: imagen
;Recorrido: booleano
;Recursion: No se usa

(define comprimir?
  (lambda(imagen)
    (if(<(length(Obtener-Listas-Pixel imagen))(*(Obtener-Ancho imagen)(Obtener-Alto imagen)))
       #t
       #f)
    )
  )

;Ejemplo uso:
;(comprimir? (imagen 2 2 (pixbit-d  0 0 1 10) (pixbit-d  0 1 0 20) (pixbit-d 1 0 0 30) (pixbit-d 1 1 1 4))) devuelve #f


;Funcion flipH
;Para realizar esta funcion es necesario el constructor imagen
;Dominio: imagen
;Recorrido: imagen
;Recursion: natural

(define flipH
  (lambda(imagen pixel-Inver)
    (if(null? imagen)
       pixel-Inver ;Si la imagen es nula, devuelve solamente pixel invertido
       ((flipH)))))



;Otras funciones que pueden ser de utilidad

;Funcion que permite reducir elementos en una lista
;Dominio: Lista X contador
;Recorrido: Lista reducida
;Recursion: Natural

(define reducir
  (lambda (L fRedux cont)
    (if (null? L) cont
        (reducir (cdr L) fRedux (fRedux (car L) cont)))))

;Funcion que permite realizar un mapeo a los elementos de una lista
;Dominio: Lista X elementos
;Recorrido: Lista
;Recursion: Natural

(define (mi-map funcion lista)
  (cond
    [(null? lista) null]
    [else
     (cons (funcion (car lista))
           (mi-map funcion (cdr lista)))]))

;Funcion que permite filtrar elementos especificos de una lista
;Dominio: Lista X pred 
;Recorrido: Lista
;Recursion: Natural

(define (mi-filtro pred lista)
  (cond
    [(null? lista) null]
    [(pred (car lista))
     (cons (car lista) (mi-filtro pred (cdr lista)))]
    [else
     (mi-filtro pred (cdr lista))]))