

;Funcion constructora de imagenes
;Estructuras basadas en listas
;Prerequisitos: Es necesario las otras funciones constructoras como bitmap, pixmap, hexmap}
;Por lo cual, antes de generar la imagen, se deben generar las otras funciones




;TDA pixbit-d (bitmap)
;Dominio: W (int) X Z (int) X bit([0|1] X depth(int))
;Recorrido: pixbit-d
;Recursion: No se usa


(define bitmap
  (lambda(X Y Bit depth)
    (if(and(integer? X)
           (integer? Y)
           (number? Bit)
           (integer? depth))
       (list X Y Bit depth)
       null)
    )
  )

;Ejemplo uso
;(bitmap 30 40 0 10)


;Pertenencia constructor bitmap
;Verificar la pertenencia si es un bitmap
;Dominio: bitmap
;Recorrido: booleano

(define bitmap?
  (lambda(bitmap? bitmap)
    (if(list? bitmap)
       (if(and(integer? (car bitmap))
              (integer?(car(cdr bitmap)))
              (number? (car(car(cdr bitmap))))
              (integer?(car(car(car(cdr bitmap)))))
             )
            #t
            #f
          )
         #f
       )
    )
  )


;Selector bitmap
;Seleccionar la coordenada X del elemento bitmap
;Dominio: bitmap X Elemento
;Recorrido: bitmap


(define(bitmap->CoordenadaX bitmap)
  (if(bitmap? bitmap)
     (car bitmap)
     null))


;Selector bitmap
;Seleccionar la coordenada Y del elemento bitmap
;Dominio: bitmap X Elemento
;Recorrido: bitmap


(define(bitmap->CoordenadaY bitmap)
  (if(bitmap? bitmap)
     (car(cdr bitmap))
     null))


;Selector bitmap
;Seleccionar el bit del elemento bitmap
;Dominio: bitmap X Elemento
;Recorrido: bitmap


(define(bitmap->Bit bitmap)
  (if(bitmap? bitmap)
     (car(cdr(cdr bitmap)))
     null))


;Selector bitmap
;Seleccionar el depth del elemento bitmap
;Dominio: bitmap X Elemento
;Recorrido: bitmap


(define(bitmap->depth bitmap)
  (if(bitmap? bitmap)
     (car(cdr(cdr(cdr bitmap))))
     null))




;Modificadores bitmap
;Apartado de funciones modificadoras para bitmap
;Dominio: bitmap X Elemento
;Recorrido: bitmap





;TDA pixrgb-d (pixmap)
;Constructor para generar un pixbit
;Dominio: W(int) X Z(int) X R(C) X G(C) X B(C) X D(int)
;Recorrido: Pixmap
;Recursion: no se usa

(define(pixmap)
  (lambda(X Y R G B D)
    (if(and(integer? X)
           (integer? Y)
           (integer? R)
           (integer? G)
           (integer? B)
           (integer? D))
       (list X Y R G B D)
       null)
    )
  )

;Pertenencia pixrgb-d->pixmap
;Constructor pixmap
;Dominio: pixmap
;Recorrido: booleano
;Recursión: No se usa

(define pixmap?
  (lambda(pixmap? pixmap)
    (if(list? pixmap)
       (if(and(integer? (car pixmap))
              (integer? (car(cdr pixmap)))
              (integer? (car(cdr(cdr pixmap))))
              (integer? (car(cdr(cdr(cdr pixmap)))))
              (integer? (car(cdr(cdr(cdr(cdr pixmap))))))
              (integer? (car(cdr(cdr(cdr(cdr(cdr pixmap)))))))
              )
          #t
          #f
          )
       #f
       )
    )
  )


;Selectores pixmap-d (pixmap)

;Selecciona la coordenada X del elemento pixmap
;En este caso toma el primer elememento del constructor del pixmap
(define(CoordenadaX->pixmap)
  (if(pixmap? pixmap)
     (car pixmap)
     null)
  )

;Selector coordenada Y del elemento pixmap
;En este caso toma el segundo elemento de la coordenada pixmap
(define(CoordenadaY->pixmap pixmap)
  (if(pixmap? pixmap)
     (car (cdr pixmap))
     null)
  )

;Selector R, elemento color (Puede tomar valor entre 0 hasta 255)
;Selecciona el tercer elemento de la lista pixmap
(define(ColorR->pixmap pixmap)
  (if(pixmap? pixmap)
     (car(cdr(cdr pixmap)))
     null)
  )

;Selector G, elemento color (Nuevamente puede tomar valores entre 0 y 255)
;Selecciona el cuarto elemento de la lista píxmap o pixbit-d
(define (ColorG->pixmap pixmap)
  (if(pixmap? pixmap)
     (car(cdr(cdr(cdr pixmap))))
     null))

;Selector B, elemento color (0-255)
;Selecciona el quinto elemento de la lista pixmap o pixbit-d
(define(ColorB->pixmap pixmap)
  (if(pixmap? pixmap)
     (car(cdr(cdr(cdr(cdr pixmap)))))
     null))

;Selector D, un valor entero cualquiera
;Selecciona el ultimo elemento de la lista pixmap o pixbit-d
(define(D->pixmap pixmap)
  (if(pixmap? pixmap)
     (car(cdr(cdr(cdr(cdr(cdr pixmap))))))
     null)
  )





;TDA pixhex-d (hexmap)
;Dominio: W(int) X Z(int) X hex(String) X d(int)
;Recorrido: pixhex
;Recursion: no se usa

(define hexmap
  (lambda(X Y hex d)
    (if(and(integer? X)
           (integer? Y)
           (string? hex)
           (integer? d))
       (list X Y hex d)
       null)
    )
  )

;Pertenencia hexmap
(define hexmap?
  (lambda(hexmap? hexmap)
    (if(list? hexmap)
       (if(and(integer? (car hexmap))
              (integer? (car(cdr hexmap)))
              (integer? (car(cdr(cdr hexmap))))
              (integer? (car(cdr(cdr(cdr hexmap)))))

              )
             #t
             #f
          )
         #f
       )
    )
  )


;Selectores hexmap o hexmap-d
;Selecciona los elementos de la lista hexmap
;En este caso se tienen que tomar todos los elementos de esa lista
;Aquí se comienza tomando la coordenada X de la lista hexmap
(define(CoordenadaX->hexmap hexmap)
  (if(hexmap? hexmap)
     (car hexmap)
     null))

;Selector hexmap coordenada Y
;Selecciona el segundo elemento de la lista hexmap
(define(CoordenadaY->hexmap hexmap)
  (if(hexmap? hexmap)
     (car(cdr hexmap))
     null))

;Selector hexmap hex
;Selecciona la parte hex de la lista hexmap
;La diferencia entre el resto de variables es que esta variable es un string
(define(Hex->hexmap hexmap)
  (if(hexmap? hexmap)
     (car(cdr(cdr hexmap)))
     null))
     
;Selector hexmap D
;Selecciona el ultimo elemento de la lista hexmap
;Es un entero
(define(D->hexmap hexmap)
  (if(hexmap? hexmap)
     (car(cdr(cdr(cdr hexmap))))
     null))





;TDA imagen
;Dominio: Largo (int) X Alto (int) X [pixbit-d*|pixrgb-d*|pixhex-d*]
;Recorrido: imagen
;Recursion: No se usa

