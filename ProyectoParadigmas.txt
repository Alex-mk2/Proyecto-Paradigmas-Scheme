#lang racket


;Definicion de(pixbit-d)
;Constructor pixbit-d
;Dominio: W(int) X Z(int) X bit(constante 0 1) X depth (int)
;Recorrido: pixbit-d
;Recursion: No se usa
;El bit en si es un numero por lo cual se considera solamente como 0 y 1

(define pixbit-d
  (lambda(X Y Bit Depth)
    (if(and(integer? X)
           (integer? Y)
           (or(= Bit 0)(= Bit 1))
           (integer? Depth))
       (cons X (cons Y(cons Bit(cons Depth null))))
       null)
    )
  )

;Ejemplo uso
;(pixbit-d 30 40 1 10)


;Selector(pixbit-d)
;Seleccionar la coordenada X del elemento pixbit-d
;Dominio: pixbit-d X elemento
;Recorrido: pixbit-d

(define Obtener-X
  (lambda(lista)
    (car lista)))

;Selector(pixbit-d)
;Seleccionar la coordenada Y del elemento pixbit-d

(define Obtener-Y
  (lambda(lista)
    (car(cdr lista))))

;Selector pixbit-d
;Seleccionar el bit del elemento pixbit-d

(define Obtener-Bit
  (lambda(lista)
    (car(cdr(cdr lista)))))

;Selector pixbit-d
;Seleccionar el depth del elemento pixbit-d

(define Obtener-Depth
  (lambda(lista)
    (car(cdr(cdr(cdr lista))))))



;TDA pixrgb-d (pixmap)
;Constructor para generar un pixbit
;Dominio: W(int) X Z(int) X R(C) X G(C) X B(C) X D(int)
;Recorrido: Pixmap
;Recursion: no se usa

(define pixrgb-d
  (lambda(X Y R G B D)
    (if(and(integer? X)
           (integer? Y)
           (<= R 255)(>= R 0)
           (<= G 255)(>= G 0)
           (<= B 255)(>= B 0)
           (integer? D))
       (cons X(cons Y(cons R(cons G(cons B(cons D null))))))
       null)
    )
  )

;Ejemplo uso
;(pixrgb-d 0 0 0 0 0 0)

;Selectores pixmap-d 
;No es necesario realizar los selectores para las coordenadas, ya que fueron creados
;Selector R, elemento color (Puede tomar valor entre 0 hasta 255)
;Selecciona el tercer elemento de la lista pixrgb-d
(define Obtener-R
  (lambda(lista)
    (car(cdr(cdr lista)))))

;Selector G, elemento color (Nuevamente puede tomar valores entre 0 y 255)
;Selecciona el cuarto elemento de la lista pixbit-d
(define Obtener-G
  (lambda(lista)
    (car(cdr(cdr(cdr lista))))))

;Selector B, elemento color (0-255)
;Selecciona el quinto elemento de la lista pixbit-d
(define Obtener-B
  (lambda(lista)
    (car(cdr(cdr(cdr(cdr lista)))))))

;Selector D, un valor entero cualquiera
;Selecciona el ultimo elemento de la lista pixbit-d
(define Obtener-D
  (lambda(lista)
    (car(cdr(cdr(cdr(cdr(cdr lista))))))))

;Constructor(pixhex-d)
;Dominio: W(int) X Z(int) X hex(string) X d(int)
;Recorrido: pixhex-d
;Recursi√≥n: No se usa
(define pixhex-d
  (lambda(X Y Hex D)
    (if(and(integer? X)
           (integer? Y)
           (string? Hex)
           (integer? D))
       (cons X(cons Y(cons Hex(cons D null))))
       null)))

;Ejemplo uso
;(pixhex-d 10 20 "Rojo" 0)


;Selectores pixhex-d
;Selecciona los elementos de la lista pixhex-d
;En este caso se tienen que tomar todos los elementos de esa lista
;Como se tienen el resto de elementos, solo se deben tomar los elementos hex y D
(define Obtener-Hex
  (lambda(lista)
    (car(cdr(cdr lista)))))

;Selector pixhex-d
;En este caso se hace seleccion del elemento D de la lista hex
;Debido a que las listas de elementos entre los tres tipos de pix son diferentes

(define Obtener-D-Hex
  (lambda(lista)
    (car(cdr(cdr(cdr lista))))))

;Constructor imagen
;Funcion constructora de la imagen
;Se deben tener los otros constructores para generar la imagen
;Dominio: Alto X Ancho X pixbit-d X pixrgb-d X pixhex-d
;Recorrido: Imagen
;Una vez obtenidos los contructores de los otros apartados, se debe construir el constructor central imagen

(define imagen
  (lambda(Alto Ancho . ConstructoresPrev)
    (cons Alto(cons Ancho(cons ConstructoresPrev null)))))

;La idea de esta funcion es utilizar los constructores generados
;Como funciones de n variable
;Ejemplo uso
;(imagen 2 2(pixbit-d 0 0 1 100)(pixbit-d 0 0 1 20)(pixbit-d 0 0 1 70)(pixbit-d 0 0 0 0))
