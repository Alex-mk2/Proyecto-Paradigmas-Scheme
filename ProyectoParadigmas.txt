

;Funcion constructora de imagenes
;Estructuras basadas en listas
;Prerequisitos: Es necesario las otras funciones constructoras como bitmap, pixmap, hexmap}
;Por lo cual, antes de generar la imagen, se deben generar las otras funciones



;Definicion de(pixbit-d)
;Constructor pixbit-d
;Dominio: W(int) X Z(int) X bit(constante 0 1) X depth (int)
;Recorrido: pixbit-d
;Recursion: No se usa
;El bit en si es un numero por lo cual se considera solamente como 0 y 1

(define pixbit-d
  (lambda(X Y Bit depth)
    (if(and(integer? X)
           (integer? Y)
           (number? Bit)
           (integer? depth))
       (list X Y Bit depth)
       null)
    )
  )

;Ejemplo uso
;(pixbit-d 30 40 0 10)


;Pertenencia constructor pixbit-d
;Verificar la pertenencia si es un pixbit-d
;Dominio: bitmap
;Recorrido: booleano

(define pixbit-d?
  (lambda(pixbit-d? pixbit-d)
    (if(list? pixbit-d)
       (if(and(integer? (car pixbit-d))
              (integer?(car(cdr pixbit-d)))
              (number? (car(cdr(cdr pixbit-d))))
              (integer?(car(cdr(cdr(cdr pixbit-d)))))
             )
            #t
            #f
          )
         #f
       )
    )
  )

;Selector bitmap (pixbit-d)
;Seleccionar la coordenada X del elemento bitmap

(define(bitmap->CoordenadaX pixbit-d)
  (if(pixbit-d? pixbit-d)
     (car pixbit-d)
     null))

;Selector(pixbit-d)
;Seleccionar la coordenada Y del elemento pixbit-d

(define(bitmap->CoordenadaY pixbit-d)
  (if(pixbit-d? pixbit-d)
     (car(cdr pixbit-d))
     null))

;Selector pixbit-d
;Seleccionar el bit del elemento pixbit-d

(define(bitmap->Bit pixbit-d)
  (if(pixbit-d? pixbit-d)
     (car(cdr(cdr pixbit-d)))
     null))

;Selector pixbit-d
;Seleccionar el depth del elemento pixbit-d

(define(bitmap->depth pixbit-d)
  (if(pixbit-d? pixbit-d)
     (car(cdr(cdr(cdr pixbit-d))))
     null))

;Modificadores pixbit-d
;Apartado de funciones modificadoras para pixbit-d
;En este caso es necesario uan funcion que nos indique el bit sea 0 o 1
;Dominio: Elemento Bit
;Recorrido: Booleano

(define Bit?
  (lambda(Bit)
    (cond
      [(pixbit-d? (car(cdr(cdr Bit))))] ;Lo que se realiza aqui es encontrar en la lista donde se almaceno el elemento bit
      [(= Bit 1) #f]
      [(= Bit 0) #t]
      [else "No es bit"])))

;Funcion para 










;TDA pixrgb-d (pixmap)
;Constructor para generar un pixbit
;Dominio: W(int) X Z(int) X R(C) X G(C) X B(C) X D(int)
;Recorrido: Pixmap
;Recursion: no se usa

(define pixrgb-d
  (lambda(X Y R G B D)
    (if(and(integer? X)
           (integer? Y)
           (integer? R)
           (integer? G)
           (integer? B)
           (integer? D))
       (list X Y R G B D)
       null)
    )
  )
;Ejemplo uso
;(pixrgb-d 0 0 0 0 0 0)

;Pertenencia pixrgb-d
;Constructor pixrgb-d
;Dominio: pixrgb-d
;Recorrido: booleano
;Recursión: No se usa

(define pixrgb-d?
  (lambda(pixrgb-d? pixrgb-d)
    (if(list? pixrgb-d)
       (if(and(integer? (car pixrgb-d))
              (integer? (car(cdr pixrgb-d)))
              (integer? (car(cdr(cdr pixrgb-d))))
              (integer? (car(cdr(cdr(cdr pixrgb-d)))))
              (integer? (car(cdr(cdr(cdr(cdr pixrgb-d))))))
              (integer? (car(cdr(cdr(cdr(cdr(cdr pixrgb-d)))))))
              )
          #t
          #f
          )
       #f
       )
    )
  )

;Selectores pixmap-d 

;Selecciona la coordenada X del elemento pixrgb-d
;En este caso toma el primer elememento del constructor del pixrgb-d
(define(CoordenadaX->pixmap pixrgb-d)
  (if(pixrgb-d? pixrgb-d)
     (car pixrgb-d)
     null)
  )

;Selector coordenada Y del elemento pixmap
;En este caso toma el segundo elemento de la coordenada pixrgb-d
(define(CoordenadaY->pixmap pixrgb-d)
  (if(pixrgb-d? pixrgb-d)
     (car (cdr pixrgb-d))
     null)
  )

;Selector R, elemento color (Puede tomar valor entre 0 hasta 255)
;Selecciona el tercer elemento de la lista pixrgb-d
(define(ColorR->pixmap pixrgb-d)
  (if(pixrgb-d? pixrgb-d)
     (car(cdr(cdr pixrgb-d)))
     null)
  )

;Selector G, elemento color (Nuevamente puede tomar valores entre 0 y 255)
;Selecciona el cuarto elemento de la lista pixbit-d
(define (ColorG->pixmap pixrgb-d)
  (if(pixrgb-d? pixrgb-d)
     (car(cdr(cdr(cdr pixrgb-d))))
     null))

;Selector B, elemento color (0-255)
;Selecciona el quinto elemento de la lista pixbit-d
(define(ColorB->pixmap pixrgb-d)
  (if(pixrgb-d? pixrgb-d)
     (car(cdr(cdr(cdr(cdr pixrgb-d)))))
     null))

;Selector D, un valor entero cualquiera
;Selecciona el ultimo elemento de la lista pixbit-d
(define(D->pixmap pixrgb-d)
  (if(pixrgb-d? pixrgb-d)
     (car(cdr(cdr(cdr(cdr(cdr pixrgb-d))))))
     null)
  )


;Constructor(pixhex-d)
;Dominio: W(int) X Z(int) X hex(string) X d(int)
;Recorrido: Hexmap
;Recursión: No se usa

(define pixhex-d
  (lambda(X Y hex d)
    (if(and(integer? X)
           (integer? Y)
           (string? hex)
           (integer? d))
       (list X Y hex d)
       null)
    )
  )
;Ejemplo uso
;(hexmap-d 10 20 "Rojo" 0)

;Pertenencia hexmap
(define pixhex-d?
  (lambda(pixhex-d? hexmap-d)
    (if(list? hexmap-d)
       (if(and(integer? (car hexmap-d))
              (integer? (car(cdr hexmap-d)))
              (integer? (car(cdr(cdr hexmap-d))))
              (integer? (car(cdr(cdr(cdr hexmap-d)))))

              )
             #t
             #f
          )
         #f
       )
    )
  )

;Selectores hexmap o hexmap-d
;Selecciona los elementos de la lista pixhex-d
;En este caso se tienen que tomar todos los elementos de esa lista
;Aquí se comienza tomando la coordenada X de la lista pixhex-d
(define(CoordenadaX->hexmap pixhex-d)
  (if(pixhex-d? pixhex-d)
     (car pixhex-d)
     null))

;Selector hexmap coordenada Y
;Selecciona el segundo elemento de la lista pixhex-d
(define(CoordenadaY->hexmap pixhex-d)
  (if(pixhex-d? pixhex-d)
     (car(cdr pixhex-d))
     null))

;Selector hex
;Selecciona la parte hex de la lista pixhex-d
;La diferencia entre el resto de variables es que esta variable es un string
(define(Hex->hexmap pixhex-d)
  (if(pixhex-d? pixhex-d)
     (car(cdr(cdr pixhex-d)))
     null))

;Selector D
;Selecciona el ultimo elemento de la lista pixhex-d
;Es un entero
(define(D->hexmap pixhex-d)
  (if(pixhex-d? pixhex-d)
     (car(cdr(cdr(cdr pixhex-d))))
     null))


;Constructor imagen
;Funcion constructora de la imagen
;Se deben tener los otros constructores para generar la imagen
;Dominio: 